from flask import Blueprint, request, jsonify
from datetime import datetime, timedelta
import pytz
import uuid
import random

from db import get_client, Entity
from config import Config
from models import user_to_dict, match_to_dict
from middleware import require_auth
from auth import get_user_by_id

match_bp = Blueprint('match', __name__)


def get_today_date_string():
    """Get today's date string in Pacific Time."""
    tz = pytz.timezone(Config.TIMEZONE)
    now = datetime.now(tz)
    return now.strftime('%Y-%m-%d')


def get_next_midnight():
    """Get the next midnight timestamp in Pacific Time."""
    tz = pytz.timezone(Config.TIMEZONE)
    now = datetime.now(tz)
    tomorrow = now + timedelta(days=1)
    midnight = tomorrow.replace(hour=0, minute=0, second=0, microsecond=0)
    return midnight.isoformat()


def get_existing_match(user_id, date):
    """Check if user already has a match today."""
    client = get_client()

    # Check as user1
    query = client.query(kind='Match')
    query.add_filter('date', '=', date)
    query.add_filter('user1Id', '=', user_id)
    results = list(query.fetch(limit=1))

    if results:
        return results[0]

    # Check as user2
    query = client.query(kind='Match')
    query.add_filter('date', '=', date)
    query.add_filter('user2Id', '=', user_id)
    results = list(query.fetch(limit=1))

    if results:
        return results[0]

    return None


def get_pool_users(date):
    """Get all users in the matching pool for today."""
    client = get_client()
    query = client.query(kind='MatchPool')
    query.add_filter('date', '=', date)
    return list(query.fetch())


def add_to_pool(user_id, date, major=None, filters=None):
    """Add user to the matching pool."""
    client = get_client()
    key = client.key('MatchPool', f'{date}_{user_id}')

    entity = Entity(key)
    entity.update({
        'userId': user_id,
        'date': date,
        'major': major,
        'filters': filters or {},
        'addedAt': datetime.utcnow().isoformat() + 'Z'
    })

    client.put(entity)


def remove_from_pool(user_id, date):
    """Remove user from the matching pool."""
    client = get_client()
    key = client.key('MatchPool', f'{date}_{user_id}')
    client.delete(key)


def create_match(user1_id, user2_id, date):
    """Create a new match between two users."""
    client = get_client()
    match_id = str(uuid.uuid4())
    key = client.key('Match', match_id)

    entity = Entity(key)
    entity.update({
        'date': date,
        'user1Id': user1_id,
        'user2Id': user2_id,
        'status': 'active',
        'disconnectedBy': None,
        'user1Pokes': 0,
        'user2Pokes': 0,
        'createdAt': datetime.utcnow().isoformat() + 'Z',
        'updatedAt': datetime.utcnow().isoformat() + 'Z'
    })

    client.put(entity)
    return entity


def get_blocked_user_ids(user_id):
    """Get list of user IDs that this user has blocked."""
    client = get_client()
    query = client.query(kind='Block')
    query.add_filter('blockerId', '=', user_id)
    return [b.get('blockedUserId') for b in query.fetch()]


def get_blocked_by_user_ids(user_id):
    """Get list of user IDs that have blocked this user."""
    client = get_client()
    query = client.query(kind='Block')
    query.add_filter('blockedUserId', '=', user_id)
    return [b.get('blockerId') for b in query.fetch()]


def find_partner_in_pool(user_id, date, user_major=None, prefer_same_major=False):
    """Find a matching partner in the pool."""
    pool_users = get_pool_users(date)

    # Get blocked users (both directions)
    blocked_ids = set(get_blocked_user_ids(user_id) + get_blocked_by_user_ids(user_id))

    # Filter out self and blocked users
    candidates = [p for p in pool_users if p.get('userId') != user_id and p.get('userId') not in blocked_ids]

    if not candidates:
        return None

    # Apply major preference if set
    if prefer_same_major and user_major:
        same_major_candidates = [p for p in candidates if p.get('major') == user_major]
        if same_major_candidates:
            candidates = same_major_candidates

    # Random selection
    return random.choice(candidates)


def format_match_for_user(match, user_id):
    """Format match entity for API response with partner info."""
    is_user1 = match.get('user1Id') == user_id
    partner_id = match.get('user2Id') if is_user1 else match.get('user1Id')
    partner = get_user_by_id(partner_id)

    # Get poke counts from perspective of current user
    my_pokes = match.get('user1Pokes', 0) if is_user1 else match.get('user2Pokes', 0)
    partner_pokes = match.get('user2Pokes', 0) if is_user1 else match.get('user1Pokes', 0)

    return {
        'id': match.key.name or str(match.key.id),
        'date': match.get('date'),
        'partnerId': partner_id,
        'partnerName': partner.get('displayName') if partner else 'Unknown',
        'partnerMajor': partner.get('major') if partner else None,
        'status': match.get('status'),
        'myPokes': my_pokes,
        'partnerPokes': partner_pokes,
        'createdAt': match.get('createdAt')
    }


@match_bp.route('/today', methods=['GET'])
@require_auth
def get_today_match():
    """Get or create today's match for the user."""
    user_id = request.user_id
    today = get_today_date_string()

    # Get user info for matching preferences
    user = get_user_by_id(user_id)
    if not user:
        return jsonify({
            'success': False,
            'error': {
                'code': 'USER_NOT_FOUND',
                'message': 'User not found'
            }
        }), 404

    user_major = user.get('major')
    user_filters = user.get('filters', {})
    prefer_same_major = user_filters.get('preferSameMajor', False)

    # Check for existing match
    existing_match = get_existing_match(user_id, today)

    if existing_match:
        if existing_match.get('status') == 'disconnected':
            return jsonify({
                'success': True,
                'data': {
                    'match': None,
                    'status': 'disconnected',
                    'message': 'You disconnected today. New match available tomorrow.',
                    'nextMatchAt': get_next_midnight()
                }
            })

        formatted_match = format_match_for_user(existing_match, user_id)
        return jsonify({
            'success': True,
            'data': {
                'match': formatted_match,
                'status': 'matched'
            }
        })

    # Try to find a partner in the pool
    partner = find_partner_in_pool(user_id, today, user_major, prefer_same_major)

    if partner:
        partner_id = partner.get('userId')

        # Create match and remove both from pool
        match = create_match(user_id, partner_id, today)
        remove_from_pool(user_id, today)
        remove_from_pool(partner_id, today)

        formatted_match = format_match_for_user(match, user_id)
        return jsonify({
            'success': True,
            'data': {
                'match': formatted_match,
                'status': 'matched'
            }
        })

    # Add to pool and wait
    add_to_pool(user_id, today, user_major, user_filters)

    return jsonify({
        'success': True,
        'data': {
            'match': None,
            'status': 'waiting',
            'message': "You're in the matching pool. Check back soon!"
        }
    })


@match_bp.route('/disconnect', methods=['POST'])
@require_auth
def disconnect():
    """Disconnect from the current match."""
    user_id = request.user_id
    today = get_today_date_string()

    # Find existing match
    existing_match = get_existing_match(user_id, today)

    if not existing_match:
        return jsonify({
            'success': False,
            'error': {
                'code': 'DISCONNECT_FAILED',
                'message': 'No active match found for today'
            }
        }), 400

    if existing_match.get('status') == 'disconnected':
        return jsonify({
            'success': False,
            'error': {
                'code': 'DISCONNECT_FAILED',
                'message': 'Already disconnected'
            }
        }), 400

    # Update match status
    client = get_client()
    existing_match['status'] = 'disconnected'
    existing_match['disconnectedBy'] = user_id
    existing_match['updatedAt'] = datetime.utcnow().isoformat() + 'Z'
    client.put(existing_match)

    return jsonify({
        'success': True,
        'data': {
            'message': 'Match disconnected. New match available tomorrow.',
            'nextMatchAt': get_next_midnight()
        }
    })


@match_bp.route('/poke', methods=['POST'])
@require_auth
def poke():
    """Poke your current match."""
    user_id = request.user_id
    today = get_today_date_string()

    # Find existing match
    existing_match = get_existing_match(user_id, today)

    if not existing_match:
        return jsonify({
            'success': False,
            'error': {
                'code': 'POKE_FAILED',
                'message': 'No active match found for today'
            }
        }), 400

    if existing_match.get('status') != 'active':
        return jsonify({
            'success': False,
            'error': {
                'code': 'POKE_FAILED',
                'message': 'Cannot poke a disconnected match'
            }
        }), 400

    # Increment poke count for the current user
    client = get_client()
    is_user1 = existing_match.get('user1Id') == user_id

    if is_user1:
        existing_match['user1Pokes'] = existing_match.get('user1Pokes', 0) + 1
    else:
        existing_match['user2Pokes'] = existing_match.get('user2Pokes', 0) + 1

    existing_match['updatedAt'] = datetime.utcnow().isoformat() + 'Z'
    client.put(existing_match)

    formatted_match = format_match_for_user(existing_match, user_id)

    return jsonify({
        'success': True,
        'data': {
            'match': formatted_match,
            'message': 'Poked!'
        }
    })


@match_bp.route('/messages', methods=['GET'])
@require_auth
def get_messages():
    """Get messages for the current match."""
    user_id = request.user_id
    today = get_today_date_string()

    # Find existing match
    existing_match = get_existing_match(user_id, today)

    if not existing_match:
        return jsonify({
            'success': False,
            'error': {
                'code': 'NO_MATCH',
                'message': 'No active match found for today'
            }
        }), 400

    match_id = existing_match.key.name or str(existing_match.key.id)

    # Get messages for this match
    client = get_client()
    query = client.query(kind='Message')
    query.add_filter('matchId', '=', match_id)
    # Note: Sorting in Python to avoid needing a composite index

    messages = []
    for msg in query.fetch():
        messages.append({
            'id': msg.key.name or str(msg.key.id),
            'matchId': msg.get('matchId'),
            'senderId': msg.get('senderId'),
            'text': msg.get('text'),
            'createdAt': msg.get('createdAt')
        })

    # Sort messages by createdAt
    messages.sort(key=lambda m: m['createdAt'])

    return jsonify({
        'success': True,
        'data': {
            'messages': messages,
            'matchId': match_id
        }
    })


@match_bp.route('/messages', methods=['POST'])
@require_auth
def send_message():
    """Send a message to your match."""
    user_id = request.user_id
    today = get_today_date_string()

    # Find existing match
    existing_match = get_existing_match(user_id, today)

    if not existing_match:
        return jsonify({
            'success': False,
            'error': {
                'code': 'NO_MATCH',
                'message': 'No active match found for today'
            }
        }), 400

    if existing_match.get('status') != 'active':
        return jsonify({
            'success': False,
            'error': {
                'code': 'MATCH_INACTIVE',
                'message': 'Cannot send messages to a disconnected match'
            }
        }), 400

    data = request.get_json()
    text = data.get('text', '').strip()

    if not text:
        return jsonify({
            'success': False,
            'error': {
                'code': 'VALIDATION_ERROR',
                'message': 'Message text is required'
            }
        }), 400

    if len(text) > 1000:
        return jsonify({
            'success': False,
            'error': {
                'code': 'VALIDATION_ERROR',
                'message': 'Message too long (max 1000 characters)'
            }
        }), 400

    match_id = existing_match.key.name or str(existing_match.key.id)

    # Create message
    client = get_client()
    message_id = str(uuid.uuid4())
    key = client.key('Message', message_id)

    entity = Entity(key)
    entity.update({
        'matchId': match_id,
        'senderId': user_id,
        'text': text,
        'createdAt': datetime.utcnow().isoformat() + 'Z'
    })

    client.put(entity)

    return jsonify({
        'success': True,
        'data': {
            'message': {
                'id': message_id,
                'matchId': match_id,
                'senderId': user_id,
                'text': text,
                'createdAt': entity.get('createdAt')
            }
        }
    })


@match_bp.route('/history', methods=['GET'])
@require_auth
def get_match_history():
    """Get past matches for the user."""
    user_id = request.user_id
    today = get_today_date_string()
    client = get_client()

    # Query matches where user is user1
    query1 = client.query(kind='Match')
    query1.add_filter('user1Id', '=', user_id)
    matches1 = list(query1.fetch())

    # Query matches where user is user2
    query2 = client.query(kind='Match')
    query2.add_filter('user2Id', '=', user_id)
    matches2 = list(query2.fetch())

    all_matches = matches1 + matches2

    # Exclude today's match, format for user
    history = []
    for match in all_matches:
        if match.get('date') == today:
            continue
        history.append(format_match_for_user(match, user_id))

    # Sort by date descending
    history.sort(key=lambda m: m['date'], reverse=True)

    return jsonify({
        'success': True,
        'data': {
            'matches': history
        }
    })


@match_bp.route('/block', methods=['POST'])
@require_auth
def block_user():
    """Block a user. Auto-disconnects active match if with that user."""
    user_id = request.user_id
    data = request.get_json()
    blocked_user_id = data.get('userId')

    if not blocked_user_id:
        return jsonify({
            'success': False,
            'error': {
                'code': 'VALIDATION_ERROR',
                'message': 'userId is required'
            }
        }), 400

    if blocked_user_id == user_id:
        return jsonify({
            'success': False,
            'error': {
                'code': 'VALIDATION_ERROR',
                'message': 'Cannot block yourself'
            }
        }), 400

    client = get_client()

    # Check if already blocked
    existing_query = client.query(kind='Block')
    existing_query.add_filter('blockerId', '=', user_id)
    existing_query.add_filter('blockedUserId', '=', blocked_user_id)
    if list(existing_query.fetch(limit=1)):
        return jsonify({
            'success': True,
            'data': {'message': 'User already blocked'}
        })

    # Create block entity
    block_id = str(uuid.uuid4())
    key = client.key('Block', block_id)
    entity = Entity(key)
    entity.update({
        'blockerId': user_id,
        'blockedUserId': blocked_user_id,
        'createdAt': datetime.utcnow().isoformat() + 'Z'
    })
    client.put(entity)

    # Auto-disconnect active match if it's with the blocked user
    today = get_today_date_string()
    existing_match = get_existing_match(user_id, today)
    if existing_match and existing_match.get('status') == 'active':
        is_user1 = existing_match.get('user1Id') == user_id
        partner_id = existing_match.get('user2Id') if is_user1 else existing_match.get('user1Id')
        if partner_id == blocked_user_id:
            existing_match['status'] = 'disconnected'
            existing_match['disconnectedBy'] = user_id
            existing_match['updatedAt'] = datetime.utcnow().isoformat() + 'Z'
            client.put(existing_match)

    return jsonify({
        'success': True,
        'data': {
            'message': 'User blocked successfully'
        }
    })


@match_bp.route('/report', methods=['POST'])
@require_auth
def report_user():
    """Report a user."""
    user_id = request.user_id
    data = request.get_json()
    reported_user_id = data.get('userId')
    reason = data.get('reason', '').strip()

    if not reported_user_id:
        return jsonify({
            'success': False,
            'error': {
                'code': 'VALIDATION_ERROR',
                'message': 'userId is required'
            }
        }), 400

    if not reason:
        return jsonify({
            'success': False,
            'error': {
                'code': 'VALIDATION_ERROR',
                'message': 'reason is required'
            }
        }), 400

    client = get_client()

    # Find the match for context
    today = get_today_date_string()
    existing_match = get_existing_match(user_id, today)
    match_id = None
    if existing_match:
        match_id = existing_match.key.name or str(existing_match.key.id)

    # Create report entity
    report_id = str(uuid.uuid4())
    key = client.key('Report', report_id)
    entity = Entity(key)
    entity.update({
        'reporterId': user_id,
        'reportedUserId': reported_user_id,
        'reason': reason,
        'matchId': match_id,
        'createdAt': datetime.utcnow().isoformat() + 'Z'
    })
    client.put(entity)

    return jsonify({
        'success': True,
        'data': {
            'message': 'Report submitted successfully'
        }
    })
